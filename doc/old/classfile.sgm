<CHAPTER LABEL="1" ID="CH-CLASSFILE">
  <TITLE>Classfile Handling</TITLE>
  <TITLEABBREV>Classfile Handling</TITLEABBREV>
  <PARA>
    <ACRONYM>KOPI</ACRONYM> classfile is an extensible package written completely in Java that
    allows you to read, edit and write classfiles. It is used by <ACRONYM>KJC</ACRONYM> (Java
    compiler), <ACRONYM>KSM</ACRONYM> (Java assembler) and <ACRONYM>DIS</ACRONYM> (Java disassembler).
  </PARA>
  <PARA>
    This list shows typical tools that may be built with KOPI Classfile:
    <ITEMIZEDLIST MARK="BULLET">
      <LISTITEM><PARA>Backend for compilers that generate code for the Java Virtual Machine;</PARA></LISTITEM>
      <LISTITEM><PARA>Java assembler;</PARA></LISTITEM>
      <LISTITEM><PARA>Optimizer for classfiles (obfuscators, code optimizers, ...);</PARA></LISTITEM>
      <LISTITEM><PARA>Bytecode level tools (instrumenters, profilers);</PARA></LISTITEM>
      <LISTITEM><PARA>Disassembler and decompiler;</PARA></LISTITEM>
      <LISTITEM><PARA>Native recompilers to C.</PARA></LISTITEM>
    </ITEMIZEDLIST>
    This package allows you to edit classfiles and to
    check and optimize instructions in an elegant way. Generated code
    from ``normal input'' is in the same order of size and speed as
    thus generated by other commercial compilers such as Javac or
    jikes. Applied optimisation is mainly peephole optimisation and
    has also faster bytecode replacement and switch selection
    capabilities. And last
    but not least, this package is able to compute the stack's depth
    and the number of local variables used by each method.
  </PARA>
  <PARA>
    There are two main sections in this chapter:
    <VARIABLELIST>
      <VARLISTENTRY>
	<TERM>The description of the tools in <XREF LINKEND="SECT-ASM">.</TERM>
	<LISTITEM>
	  <PARA>
	    An assembly language for the Java classfile format.
	  </PARA>
	  <PARA>
	    Two tools are available:
	  </PARA>
	  <VARIABLELIST>
	    <VARLISTENTRY>
	      <TERM>The documentation for the disassembler in <XREF LINKEND="SECT-DIS">.</TERM>
	      <LISTITEM>
		<PARA>
		  a Java disassembler that allows one to read and edit a
		  classfile in kopi-assembler.
		</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM>The documentation for the assembler in <XREF LINKEND="SECT-KSM">.</TERM>
	      <LISTITEM>
		<PARA>
		  a Java assembler used to write classfile from kopi-assembler.
		</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	  </VARIABLELIST>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>The description of the API in <XREF LINKEND="SECT-CLASSFILE">.</TERM>
	<LISTITEM>
	  <PARA>
	    The package classfile itself, that allows one to handle
	    Java code generation from within an other Java application
	    without worrying about code optimization, stackand local
	    variable handling, code checking and constant pool
	    optimization.
	  </PARA>
	  <VARIABLELIST>
	    <VARLISTENTRY>
	      <TERM>The core API in <XREF LINKEND="SECT-API">.</TERM>
	      <LISTITEM>
		<PARA>
		  An API for embedding Java code generation in other tools.
		</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM>The performed optimizations in <XREF LINKEND="SECT-OPTI">.</TERM>
	      <LISTITEM>
		<PARA>
		  An in depth report about performed optimizations.
		</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	  </VARIABLELIST> 
        </LISTITEM>
      </VARLISTENTRY>
    </VARIABLELIST>
  </PARA>
  
  <SECT1 ID="SECT-ASM"><TITLE>KOPI Assembly Language</TITLE>
    <PARA>
      The syntax was designed to be both readable and fully functional
      (It keep a total power of expression). The primary goal was to
      let the assembler (the classfile API) do as much work as
      possible, making for example unnecessary to specify the maximum
      amount of stack used or the number of local variables, since 
      this information can be deduced from the program to assemble. The
      instructions opcodes are limited to the strict minimum, and all
      the instructions defined to optimize a program (such as load_1)
      will be replaced by the assembler from generics instructions
      (from load 1).
    </PARA>
    <SECT2><TITLE>File structure</TITLE>
      <PARA>
	The file structure is similar to a Java compilation unit.
	The syntax looks like a normal Java program for the member's
	definition. Only the method body is described in assembler. Some
	special information found in classfiles such as LineNumberTable,
	LocalVariableTable and attributes are also defined in the method
	body, but all of this information is optional.
      </PARA>
      <PARA>
        The code of methods is pure Java assembler as defined at <ULINK URL="http://java.sun.com/docs/books/vmspec/2nd-edition/html/Instructions.doc.html">http://java.sun.com/docs/books/vmspec/2nd-edition/html/Instructions.doc.html</ULINK>.
      </PARA>
      <PARA>
	The easiest way to understand KOPI assembler is to look at an
	example or to decompile your own classes with <ACRONYM>DIS</ACRONYM>.
      </PARA>
      <SECT3><TITLE>Example</TITLE>
	<PARA>
	  <PROGRAMLISTING>
  // compiler version: 45.3
  
  @source "HelloWorldApp.java"
  class HelloWorldApp extends java.lang.Object {
  
      /**
       * main
       *
       * @stack   2
       * @locals  1
       */
      public static void main(java.lang.String[]) {
          @line   3
                  @getstatic      java.io.PrintStream java.lang.System.out
                  @const          "Hello World!"
                  @invokevirtual  void java.io.PrintStream.println(java.lang.String)
          @line   2
                  @return
      }
  
      /**
       * init
       *
       * @stack   1
       * @locals  1
       */
      void init() {
          @line   1
                  @aload          0
                  @invokespecial  void java.lang.Object.init()
                  @return
      }
  }
          </PROGRAMLISTING>
        </PARA>
      </SECT3>
    </SECT2>
    
    <SECT2 ID="SECT-KSM"><TITLE>The KOPI Assembler (<ACRONYM>KSM</ACRONYM>)</TITLE>
      <NOTE><TITLE>License type</TITLE>
	<PARA>
	  KSM is distributed under the terms of the GNU General Public License.
	  <XREF LINKEND="APX-GPL">
	</PARA>
      </NOTE>
      <PARA>
	To launch <ACRONYM>KSM</ACRONYM> from the command line, type 
	<SCREEN>
  java at.dms.ksm.Main
	</SCREEN>
	The command line parameters are: 
	<SCREEN>
  java at.dms.ksm.Main [dhV] file.ksm+
    usage: at.dms.ksm.Main [option]* [--help] files.ksm
    --destination, d _: Sets the destination directory
    --help, h: displays the help information
    --verbose, v: Displays information while processing files [false]
    --version, V: prints out the version information
      file: the files to assemble
	</SCREEN>	
      </PARA>
    </SECT2>
    
    <SECT2 ID="SECT-DIS"><TITLE>The KOPI Disassembler (<ACRONYM>DIS</ACRONYM>)</TITLE>
      <NOTE><TITLE>License type</TITLE>
	<PARA>
	  DIS is distributed under the terms of the GNU PUBLIC License.
	  <XREF LINKEND="APX-GPL">
	</PARA>
      </NOTE>
      <PARA>
	This tool allows you to see the code actually generated by
	your compiler and may help you to optimize or understand a
	portion of the code. This tool may also help you modify some
	classes from their bytecode in conjunction with <ACRONYM>KSM</ACRONYM>(to
	regenerate them).
      </PARA>
      <PARA>
	To launch <ACRONYM>KSM</ACRONYM> from the command line, type:
	<SCREEN>
  java at.dms.dis.Main
	</SCREEN>
	The command line parameters are: 
	<SCREEN>
  java at.dms.dis.Main [cdhisxV] (file.class | class)+
    --classpath, p _: Sets the classpath
    --destination, d _: Sets the destination directory
    --help, h: displays the help information
    --inter, i: Only displays the interfaces of classes [false]
    --sorted, s: Prints fields and methods sorted [false]
    --stack, x: Prints stack information [false]
    --stdout, c: Prints on the standard output [false]
    --verbose, v: Displays information while processing files [false]
    --version, V: prints out the version information
      class: a class (fully qualified name) accessible from the current classpath
	</SCREEN>
      </PARA>
    </SECT2>
  </SECT1>

  <SECT1 ID="SECT-CLASSFILE"><TITLE>KOPI Classfile API</TITLE>
  <NOTE><TITLE>License type</TITLE>
    <PARA>
      KOPI Classfile is distributed under the terms of the GNU Lesser General Public License.
      <XREF LINKEND="APX-LGPL">
    </PARA>
  </NOTE>
    <PARA>
      This package contains the API to edit classfiles from within a
      Java program. If you want to read or write classfiles in a human
      readable form, you should use <ACRONYM>KSM</ACRONYM> and
      <ACRONYM>DIS</ACRONYM> which offer an interface to classfile.
    </PARA>
    <PARA>
      Basically, this package contains three parts: one to read data
      from a file, one to create a consistant class from another
      program, and a third part to check the code of each function
      (compute stack and local variable usage, and optionnally optimize
      code) and then dump the class into a file.
    </PARA>
    
    <SECT2 ID="SECT-API"><TITLE>Read a classfile</TITLE>
      <PARA>
	You just have to create a ClassInfo from a file:
	<PROGRAMLISTING>
	  ClassInfo clazz = new ClassInfo(new
	  RandomAccessFile(``AClass.class''), false);
	</PROGRAMLISTING>
	or with its full name and a class path using the provided class ClassPath:
	<PROGRAMLISTING>	
  ClassPath path = new ClassPath(``.''); 
  ClassInfo clazz = path.getClassFile(``pack.AClass'', true);
  // rmq: the last parameter allows you 
  //      to load only the interface (skip code)
	</PROGRAMLISTING>	  
	Once you've read your class, you can access all the information
	you need from the provided API such as getName(),
	getSuperClass(), getMethods(), getSourceFile(). If you have
	loaded an entire class (not only the interface), you'll be able
	to change some information (the source file, the name, some
	modifiers...) and then to dump it to file again.
      </PARA>
    </SECT2>
    
    <SECT2><TITLE>Create, edit, optimize and check a classfile</TITLE>
      <PARA>
      </PARA>
      <SECT3><TITLE>Create a class from scratch</TITLE>
	<PARA>
	  You can create a class from scratch and then add all the attributes and
	  members you want. See <ACRONYM>KSM</ACRONYM> or <ACRONYM>KJC</ACRONYM> for a real example of usage.
	</PARA>
      </SECT3>
      <SECT3><TITLE>Edit a class</TITLE>
	<PARA>
	  You can edit your class using the provided API:
	  <PROGRAMLISTING>	  
  ClassInfo clazz = new ClassInfo(new File(``AClass.class''); 
  clazz.setName(``BClass'');
	  </PROGRAMLISTING>	  
	</PARA>
      </SECT3>
      <SECT3><TITLE>Optimize and check a classfile</TITLE>
	<PARA>
	  After you have built or edited the instructions, you can check and optimize
	  the code:
	  <PROGRAMLISTING>	  	  
  // obtained from any non empty method
  CodeInfo code = clazz.getMethods()[0]; 
  // 2 is the number of optimization loop, 0 for none
  code.optimizeAndCheck(2) 
	  </PROGRAMLISTING>
	  The main check is to ensure that the stack depth is correct
	  for every branch in the program. We may add later some
	  verifications made by the Java Verifier at runtime.
	</PARA>
      </SECT3>
    </SECT2>
    
    <SECT2><TITLE>Write a classfile</TITLE>
      <PARA>
      </PARA>
      <SECT3><TITLE>Write a .class file</TITLE>
	<PARA>
	  After you have built or edited a ClassInfo, you can dump it into a file
	  with:
	  <PROGRAMLISTING>	  
	    ClassInfo clazz = new ClassInfo(new File(``AClass.class''); 
	    clazz.setName(``BClass'')
	    clazz.write(new DataOutputStream(new FileOutputStream(``BClass.class'');
	  </PROGRAMLISTING>	  
	</PARA>
      </SECT3>
      <SECT3><TITLE>Example</TITLE>
	<PARA>
	  This simple example sets all methods to be public in the class passed
	  as argv[0] and writes this new class in a file argv[1]
	  <PROGRAMLISTING>
  /** 
   * This simple example set all methods to 
   * be public in the class passed as first
   * parameters and write this new class in a file argv[1]
   */	    
  import at.dms.classfile.*; 
  import java.io.*;
  
  public class Editor implements Constants { 
    public static void main(String[] argv) 
    throws at.dms.classfile.ClassFileFormatException, 
           java.io.FileNotFoundException, 
           java.io.IOException 
    { 
      DataInputStream is = new DataInputStream(new FileInputStream(argv[0]));
    
      ClassInfo clazz = new ClassInfo(is, false); 
      MethodInfo[] method = clazz.getMethods(); 
      
      for (int i = 0; i < method.length; i++) 
        method[i].setModifiers(toPublic(method[i].getModifiers())); 
      
      clazz.write(new DataOutputStream(new FileOutputStream(argv[1])));
    } 
    private static short toPublic(short modifiers) { 
      return (short)((modifiers | ACC_PUBLIC) &
		       ~(ACC_PROTECTED | ACC_PRIVATE));
    } 
  }
	  </PROGRAMLISTING>
	</PARA>
      </SECT3>
      <SECT3><TITLE>Where to use this package</TITLE>
	<PARA>
	  This is a list of non restrictive possible tools to build with this package:
	  <ITEMIZEDLIST MARK="BULLET">
	    <LISTITEM><PARA>Back end for compilers that generates code for the Java Virtual Machine</PARA>
	      <PARA>
		There are two fully implemented examples that come with <ACRONYM>KOPI</ACRONYM> suite:
		<ITEMIZEDLIST MARK="BULLET">
		  <LISTITEM><PARA><ACRONYM>KSM</ACRONYM> Kopi assembler</PARA>
		    <PARA>
		      This is a small example to show how a ``high level'' 
                      assembly language is translated into Java bytecode. This
                      example is very small (10
		      classes) and is a good starting point for learning how
		      the classfile package works.  <ACRONYM>KSM</ACRONYM> is composed of
		      a parser that reads ``.ksm'' files and some
		      subclasses of classfiles for handling assembler
		      labels and jumps. <ACRONYM>KSM</ACRONYM> syntax is easy because you
		      don't have to use the most optimized
		      pseudo-instruction in your code, you can use
		      generic instruction that classfile will optimize
		      afterwards. 
	            </PARA>
                    <PARA>
                      By example if you use ``push 1'' to push
		      the constant one into the stack, classfile will
		      translate this instruction to ``iconst_1'', which
		      is smaller and faster. Another feature of <ACRONYM>KSM</ACRONYM>
		      is that you don't have to compute the amount of
		      stack used, or the number of local variables;
		      the classfile package will do it for you.
		    </PARA>
		  </LISTITEM>
		  <LISTITEM><PARA><ACRONYM>KJC</ACRONYM> Kopi Java Compiler</PARA>
		    <PARA>
		      This is a big example (160 classes) that shows
		      how to use the classfile package as a back end
		      for a compiler. Classfile was first designed as
		      a part of <ACRONYM>KJC</ACRONYM>, but because this package may be used
		      for other purposes, it has been separated from the
		      compiler. That makes the code easy to handle and
		      improve.
		    </PARA>
		  </LISTITEM>
		</ITEMIZEDLIST>
	      </PARA>
	    </LISTITEM>
	    <LISTITEM><PARA>Optimizer for classfiles (obfuscators, code optimizers, ...).</PARA>
	      <PARA>
		It is also very easy to create a classfile
		optimizer. We will soon provide a minimalist code optimizer
		that can read every classfile provided and generates
		optimized versions in the destination directory. Our
		optimizer will be used only for testing purpose and won't do
		anything more than:
		<ITEMIZEDLIST>
		<LISTITEM>
		    <PARA>
		      Unnecessary information removal (local vars, line
		      numbers, source file attibutes).
		    </PARA>
		</LISTITEM>
		  <LISTITEM>
		    <PARA>
		      Bytecode optimization (equivalent to -O2 of <ACRONYM>KJC</ACRONYM>).
		    </PARA>
		  </LISTITEM>
		</ITEMIZEDLIST>
		</PARA>
	      <PARA>
		But it would be very easy to transform it to a true
		obfuscator/optimizer by collecting used fields and
		methods and renaming every member of class to the
		smallest size possible.
	      </PARA>
	    </LISTITEM>
	    <LISTITEM><PARA>5.3 Disassemblers</PARA>
	      <PARA>
		It is very easy to build a disassembler over KOPI classfile
		by accessing every information in the classfile with
		the provided API.  An example of such a disassembler,
		<ACRONYM>DIS</ACRONYM>, is provided with the
		<ACRONYM>KOPI</ACRONYM> suite. It converts classfile in
		a syntax that is understood by <ACRONYM>KSM</ACRONYM>.
		That allows you to disassemble a classfile, modify
		some code, and then regenerate the classfiles. Our
		disassembler is very small also but powerful enough to
		disassemble every classfiles into
		<ACRONYM>KSM</ACRONYM> syntax. And, if you want to
		disassemble classfiles in another syntax, you just
		have to subclass the AssemblerPrettyPrinter.
	      </PARA>
	    </LISTITEM>
	    <LISTITEM><PARA>Native recompilers to C</PARA>
	      <PARA>
		From the classfile assembler, it is all the same to
		generate Java byte code or C. The problem of such
		tools is to provide a gc and a window toolkit. but it
		should not be to difficult to create a tool that
		compiles natively command-line Java programs.
	      </PARA>
	    </LISTITEM>
	    <LISTITEM><PARA>Cross reference tool</PARA>
	      <PARA>
		A useful tool based on the KOPI classfile may be a cross
		reference analyser.
	      </PARA>
	    </LISTITEM>
	  </ITEMIZEDLIST>
	</PARA>
      </SECT3>
    </SECT2>
    <SECT2 ID="SECT-OPTI"><TITLE>Pluggable Bytecode optimizer</TITLE>
      <HIGHLIGHTS>
	<PARA>This chapter explains which optimisations are provided
	  by the bytecode optimizer.  These optimizations are:
	</PARA>
	<ITEMIZEDLIST MARK="BULLET">
	  <LISTITEM><PARA>Unreachable code elimination.</PARA></LISTITEM>
	  <LISTITEM><PARA>Jump and peephole optimizations.</PARA></LISTITEM>
	</ITEMIZEDLIST>
      </HIGHLIGHTS>
      
      <SECT3><TITLE>The KOPI Optimizer</TITLE> 
	<NOTE><TITLE>License type</TITLE>
	  <PARA>
	    optimize is distributed under the terms of the GNU PUBLIC License.
	    <XREF LINKEND="APX-GPL">
	  </PARA>
	</NOTE>
	<PARA>
	  This tool allows you to optimize a classfile or a complete
	  directory using the optimizer engine of kjc on already
	  generated classfiles. This tool exists mainly for testing
	  purpose.
	</PARA>
	<PARA>
	  To launch optimize from the command line, type:
	  <SCREEN>
  java at.dms.optimize.Main
	  </SCREEN>
	The command line parameters are: 
	  <SCREEN>
  java at.dms.optimize.Main (file.class | directory)+
    --help, h: displays the help information
    --level, l _: Level of optimization [2]
    --verbose, v: Displays information while processing files [false]
    --version, V: prints out the version information
      class: a class (fully qualified name) accessible from the current classpath
	  </SCREEN>
	</PARA>
      </SECT3>
      <SECT3><TITLE>Unreachable code optimization</TITLE> 
	<PARA>Unreachable code is simply removed from the CodeInfo. And
	  <COMMAND>nop instructions</COMMAND> are removed if they are not targeted in a method.
	</PARA>
      </SECT3>
      <SECT3><TITLE>Jump and peephole optimization</TITLE>
	<PARA>This is the current list of peephole optimization performed by <ACRONYM>KJC</ACRONYM>:
	</PARA>
	<ITEMIZEDLIST MARK="BULLET">
	  <LISTITEM><PARA>Jumps to the following instruction.</PARA>
	    <PROGRAMLISTING>
	      goto		L1
	      L1:	...	
	      =>
	      ...
	    </PROGRAMLISTING>
	  </LISTITEM>
	  
	  <LISTITEM><PARA>Jumps to next instruction.</PARA>
	  <PROGRAMLISTING>
	      ...
	      ifeq		L1
	      L1:	...	
	      =>
	      ...
	      pop[2]
	      ...
	    </PROGRAMLISTING>
	  </LISTITEM>
	  <LISTITEM><PARA>Jump to unconditional jumps.</PARA>
	  <PROGRAMLISTING>
	      ...
	      opc_goto	L1
	      ...
	      L1:	goto		L2	
	      =>
	      ...
	      goto		L2
	      ...
	      L1:	goto		L2	
	    </PROGRAMLISTING>
	  </LISTITEM>
	  <LISTITEM><PARA>Goto to return instruction.</PARA>
	    <PROGRAMLISTING>
	      ...
	      goto		L1
	      ...
	      L1:	ireturn	
	      =>
	      ...
	      ireturn
	      ...
	      ireturn	
	    </PROGRAMLISTING>
	  </LISTITEM>
	  <LISTITEM><PARA>Peephole optimizations.</PARA>
	    <PARA>
	      <PROGRAMLISTING>
		iconst_0
		ifeq		L1
		...
		L1:	...	
		=>
		...
		L1:	...	
	      </PROGRAMLISTING>
	      or
	      <PROGRAMLISTING>
		iconst_[0, 1, null]
		if_icmpeq		L1
		...
		L1:	...	
		=>
		ifeq			L1
		...
		L1:	...	
	      </PROGRAMLISTING>
	    </PARA>
	  </LISTITEM>
	</ITEMIZEDLIST>
      </SECT3>
    </SECT2>
  </SECT1>
</CHAPTER>
